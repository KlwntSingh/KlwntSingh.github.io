---
title: Transport Layer(L4)
layout: post
---
      

# Transport Layer(L4)  

## TCP   

* connection oriented   

### flow control   

* using windows   

### reliable   

* by retransmission   

* connection is established before sending data   

* everything is acknowledged   

### Slow Start   

#### when congestion occurs does a slow start   

##### Here, window size increases on every acknowledge is received and decreases if no acknowledgement arrives in round trip time   

* window size is reduces to 1 when packet is dropped, and than again window size increases exponentially to half the value of initial window size, than it increases linearly   

#### also concept of tcp global  synchronisation, in which all the tcp connections are reset to window size 1 after congestion   

* To avoid tcp global synhcronisation, we use RED(Random early detection) where we drop packet before the queue is full at random based on number of packets in queue and TOS(type of service)   

### Window size = 16 bits	max possible 65535   

* Number of bytes can be sent before receiving acknowledgment   

* but now using wss(window size scale) factor we can have larger window sizes   

## UDP   

### no sequencing   

#### than how sequencing happens in voip   

* RTP(Real Time protocol used above udp uses sequencing)   

* connectionless   

## ports   

### well known port numbers   

* 0-1023   

* servers uses these ports   

### ephemeral port numbers   

* 1024-5000   

* clients use these ports as clients are temporary   

## points   

* broadcasting and multicasting does not apply to TCP, it only applies to udp   

### why packet length field is present in udp and not in tcp   

* header field in udp header is redundant.tcp only has header length field and that is because of additional options field but size of udp header is fixed   

* In TCP, data generated by application might be broken into smaller segments or multiple data chunks concatenated to form bigger segments   

* In UDP, there is one to one mapping of data generated by application and udp segment created   

# TCP header  

## TCP   

* Source Port   

* Destination port   

* Sequence Number   

* Acknowledgement No   

### DO   

#### 4 bit   

* Tells size of tcp header   

### RSV   

* 3 bit   

### Flags   

* SYN   

* RST   

* FIN   

* PSH   

* ACK   

* URG   

* Window size   

* checksum   

### options   

#### max - 40 bytes(whole tcp header takes 60 bytes)   

* as other header fields are 20 bytes   

### urgent pointer   

* tells the location where urgent data ends   

## fields   

### source port number   

* 2 byte   

### destination port number   

* 2 byte   

### sequence number   

* 4 byte   

### acknowledgement number   

* 4 byte   

### header length   

* 4 bit   

* usually used for options   

### reserved bits   

* 6 bits   

### flags   

* 6 bits   

#### URG   

* used to send urgent data after push flag data has been sent   

* ACK   

#### PSH   

* want to push data without waiting for additional data   

* RST   

* SYN   

* FIN   

### windows size   

* 2 byte   

### checksum   

* 2byte   

* covers both header and data   

### urgent pointer   

* 2byte   

### options   

#### mss - maximum segment size   

* this is sent by sender in syn segment   

* this specifies the maximum sized segment that sender wants to receive   

* default value is 536 bytes   

#### wss - window scale size   

* this is used to scale the window size   

## theory   

* 1. socket is ip address + port no.   

### each sequence number identifies each byte   

#### when syn flag is on, sequence number field contains isn(initial sequence number).initial sequence no. is increasing every 4 microseconds   

* why syn flag and fin flag consumes sequence number?because they themselves can be acknowledged and resent in-case lost   

* syn and fin cosumes sequence number   

### asknowlegement number is expected sequence number for next segment. hence it is one plus recently received sequence number   

* acknolwgedment number is valid if ack flag is on   

* ack cost nothing because ack flag and ack sequence number is both part of header. hence no sequence number is wasted in this ack   

* support cummulative acknowledgements but does not support selective acknowledgement or negative acknowledgements   

### cases of sending segment without data   

* ack   

* syn and fin   

* timeouts   

### MSL   

* time after final ack is sent, connection is left open for some time   

#### two reasons for doing this   

* another cannot try to open with same port no. hence it protects from any previous segments which might corrupt the connection   

* if ack to fin is lost than, another end can retransmit it's fin segment and we can send ack for that   

* typically 2 minutes   

### RST used by tcp when no process is listening on port.udp uses icmp error with port uncreachable   

* When RST is sent, all the sending data from queue is thrown away   

### two styles of communication   

#### interactive(stop and wait)means one by one   

##### piggy backing   

* data is sent along with ack, to save no. of segments sent   

##### delayed ack   

* sometimes data is not ready and timer expires so, ack alone are sent   

* usually happens from sender side as speed of typing of person is slow, so timer expires before data can be appended with ack   

##### naggle algorithm   

* this technique is used over wan when we want to reduce no. of segments and save bandwidth   

* where we bulk together some of data to be sent together   

* speed of data transfer depends on speed of receving back the acks   

* Both are interelated ideas, if data is some additional data is present than piggy backing happens.otherwise waits for delayed ack timer to expire and than ack alone is sent   

#### bulksliding window   

* Congestion avoidance algorithmslow start   

##### fast retransmission   

* after 3 acks are received, lost segment is retransmitted   

##### fast recovery   

* recovery from fast retransmission by not starting from slow start again   

### Difference   

#### mss vs ws   

##### meaning   

* maximum data sent in one segmetn   

* maximum data which can be present on wire in one or multiple segments   

### timers   

#### retransmission timer   

* backoff algorithm kicks in   

#### delayed ack   

* 200ms   

#### persist timer   

* Problem it solves: when sender is getting ack with size window 0 and other acks with size greater than 0 are getting lost. then there will be deadlock.To avoid this, sender after persist timeout keep sending window probe segments to see if window size increased   

* How: these window probe send 1 byte of data. Now this data will be rejected by other side if window size is 0 and other side will bend ack with window size 0 and ack for same sequence number as of 1 byte of data sent. but if 1 byte of data sent is received than ack is sent with sequence number of next bytes of data with windows size non-zero   

##### One issue arrises from this, Silly window syndrome   

* small amout of data getting exchanged across the connection   

###### receiver silly window syndrome avoidance technique   
it does nto send window update untill maximum segment size window is achieved   

* maximum segment size is decided from mss option during connection establishment   

* One condition when receiver does not follow this technique, and this is when window of bigger size is sent back to sender and than sender has less data to send so rather than sending back window size 0 it send left size window back because if it does not than tcp rule of not shrinking window will be broken   

###### sender silly windows avoindance technique   

* sender does not send until maximum segment size data is achieved   

###### One scenario where silly window syndrome avoidance restriction is rejected   

* when non-zero window size is received and than data which is to be sent is less than the window size, we send it and than receiver rather than sending window size to be 0 to be silly window syndrome, sent the left bytes of window size because other tcp window size contraction will occur   

##### time ranges from 5sec to 60sec   

* time increase by multiplication of previous value with 2 and starts with 5 sec   

#### keepalive timer   

* why: to close all half open connection on server size. This option of sending keepalive probes are from server side   

* how: server send sequence number one less than expected sequence number by other end, hence other side to correct server that it already know about the sequence number and send ack with correct sequence number to be sent next time.   

##### this is probe with no data which receives ack   

* other segments which receive ack for no data are syn, fin, rst etc   

##### keepalive probes are sent every 2 hours with wait time for ack of 75ms   

* this process continues for next 10 probes if no response is there   

# UDP header  

## source port number   

* 2 byte   

## destination port number   

* 2 byte   

## checksum   

* 2 byte   

* It is optional   

* covers both header and data   

## udp length   

* 2 byte   

* Redundant as IP layer has packet length field, udp data can be deducted from that.That is why tcp header does not have segment length field, it only has header length field   

* incorrect packets are discarded without any icmp error   

# TFTP  

## message types   

### READ   

* contains filesname and transfer mode(ascii or binay)   

* WRITE   

### DATA   

* has sequence number   

### ACK   

* also has sequence number which the message is acknowledging   

* ERROR   

* udp based protocol used port 69   

* tftp block of 512 bytes is used when sending data   

* this is stop and wait. once tftp block has been sent, it waits for ack before sending second tftp data block   

* Does not provide authentication and rich set of user interface commands   
